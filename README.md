
# Навигация
[Перейти к Linux](#linux)  
[Перейти к LinuxNetwork](#linuxnetwork)  
[Перейти к Docker](#docker)  
[Перейти к CI/CD](#ci-cd)


# Linux
## Задание 1. Установка ОС
> Установленная версия UBUNTU Server 20.04

![Example1](materials\example_00\EX_1.png)





## Задание 2. Создание пользователя
<image src="materials\example_01\EX_2.0.png" alt="Рис. 2">

> Команда создания пользователя с ником admin, с ключом G для включение его в группу 
  пользователей adm
  
![Example2](materials\example_01\EX_2.1.1.png "Рис. 2.1")
> Результат выполнения комманды. А также вывод команды getent group adm - выводящая список
>пользователей входящих в группу adm
>
![Example2](materials\example_01\EX_2.1.png "Рис. 2.2")
> Вывод команды cat /etc/passwd. /etc/passwd, содержит информацию о учетных записях пользователей. Каждая строка в этом файле представляет собой учетную запись пользователя и включает такие данные, как имя пользователя, идентификатор пользователя (UID), идентификатор группы (GID), домашний каталог и оболочку по умолчанию.

## Задание 3. Настройка сети ОС 
### Меняем имя ХОСТА 3.1

![Example3](materials\example_02\1.png "Старое название хоста")
> Старое назавние хоста

![Example3](materials\example_02\2.png "Изминение имени машины")
> Командой hostname запущеной от имени администратора меняем имя машины на user-1. После чего вводим
>снова комманду hostname убиждаясь что имя хоста изменено.

Чтобы имя сервера было осталось user-1 после перезагрузки не обходимо отредактировать файл hostname а также hosts

## Устанавливаем временную зону.

![Example3](materials\example_02\timezone_1.png "Временная зона до изминения")
> Time zone до внесения изменений

![Example3](materials\example_02\timezone_2.png "данная команда позвоялет вывести список доступных временных зон")
> с помощью команды `timedatectl list-timezone` узнаем доступные временные зоны

![Example3](materials\example_02\timezone_3.png "устанавливаем временную зону")
> с помощю команды `timedatectl set-timezone Europe/Moscow` устанавливаем временную зону 

Выведем названия сетевых интерфейсов с помощью команды `ip link show` или `ip address` а также `ls /sys/class/net`
![Example3](materials\example_02\ip.png "Вывод команды ip link show")
> 1: lo - Это  интерфейс "loopback", который используется для связи с самим собой.

> 2: enp0s3: - это имя Ethernet-интерфейса
>  - где en казывает, что это Ethernet-интерфейс. 
>  - p0 указывает на номер шины (bus number).
>  - s3 указывает на номер слота (slot number).

Выводы команд `ip address` и `ls/sys/class/net`
![Example3](materials\example_02\ip_1.png "Вывод команд")
>Команда `ls/sys/class/net` выводит список всех сетевых интерфейсов, доступных на устройстве. Каждый интерфейс представлен в виде каталог, в данном случае их два enp0s3 и lo.
### Об интерфейсе lo
Интерфейс lo, также известный как loopback интерфейс, является специальным сетевым интерфейсом в операционных системах, включая Linux. 
Назначение интерфейса lo
   - Локальная связь: Интерфейс lo используется для связи внутри самой системы. Он позволяет программам и службам на одном компьютере обмениваться данными друг с другом, не выходя в сеть. Это особенно полезно для тестирования и разработки.Обычно имеет IP-адрес 127.0.0.1, который также называется localhost. Этот адрес всегда ссылается на сам компьютер, что позволяет программам обращаться к себе.

   - Также использование loopback интерфейса позволяет изолировать сетевые операции от внешних сетей. Это означает, что любые данные, отправленные на lo, не покинут компьютер, что может быть полезно для тестирования сетевых приложений без необходимости подключения к внешним сетям.

   - Поскольку данные, передаваемые через loopback интерфейс, не требуют физической передачи по сети, это обеспечивает высокую скорость и низкую задержку при обмене данными между процессами на одном устройстве.

#### Примеры использования
   Тестирование веб-серверов: можно запустить веб-сервер на своем компьютере и тестировать его, обращаясь к http://127.0.0.1 или http://localhost.
   
   Программы, которые требуют сетевого взаимодействия, могут использовать loopback интерфейс для связи между собой без необходимости использования внешних сетевых ресурсов.
     
   
### ip адрес VM
Вывести ip адрес VM можно использую данные команды `hostname -I` и `ip addr show`
![Example3](materials\example_02\ip_2.png "ip адрес виртуальной машины")
```
cat /var/log/syslog | grep -i dhcp
```
![Example3](materials\example_02\ip_3.png)
- Для того,чтобы узнать внешний ip-адрес шлюза (ip) используем команду:

```
curl ifconfig.co
```
![Example3](materials\example_02\ip_4.png)


### Расшифрока DHCP
#### DHCP расшифровывается как Dynamic Host Configuration Protocol (Протокол динамической конфигурации узлов). Это сетевой протокол, который используется для автоматической настройки параметров сетевых устройств (узлов) в IP-сетях.

### Выведем внутренний и внешний ip адерс шлюза
вывод команд `ip -a route` и `route -n`
>  - Причиание для выполнения `route -n` не обходимо сначало установить net-tools

![Example3](materials\example_02\ip_5.png)
![Example3](materials\example_02\ip_6.png)
> Внутренний ip адрес шлюза 10.0.2.2

![Example3](materials\example_02\ip_4.png)
> Внешний ip адрес шлюза 95.86.229.213

### Зададим статичные ip, gw (gateway), dns 

Для этого необходимо отключить автоматическое выделение адресов DHCP сервером в конфигурационном файле 00-installer-config.yaml по пути 
```
/etc/netplan/00-installer-config.yaml 
``` 

Зададим статические настройки: изменим параметр dhcp4 на значение false, в addresses укажем статический IP-адрес: 10.0.2.4/24, и в gateway4 зададим внутренний IP-адрес 10.0.2.2. В параметре addresses раздела nameservers укажем публичные сервера 8.8.8.8 и 1.1.1.1.

![Example3](materials\example_02\net_1.png)

Для того что бы изменения вступили в силу необходимо использовать команду 
```
sudo netplan apply 
```
![Example3](materials\example_02\net_2.png)

После чего необходимо перезагрузить систему и проверить что изменения которые мы внесли остались.

- Вывод команд:
  - cat /etc/netplan/00-installer-config.yaml
  - ip route show
  - ifconfig

![Example3](materials\example_02\reboot1.png)
![Example3](materials\example_02\reboot2.png)
![Example3](materials\example_02\reboot3.png)

### Проверим что мы имеем доступ в интернет выполним команду `ping`

![Example3](materials\example_02\ping1.png "ping до 1.1.1.1")
> ping до 1.1.1.1

![Example3](materials\example_02\ping2.png "ping до www.ya.ru")
> ping до www.ya.ru

## Задание 4. Обновление пакетов ОС
Для обновление системы необходимо сначало обновить список пакетов с помощью команды 
```
sudo apt update
```
После чего осуществить обновление пакетов с помощью команды
```
sudo apt upgrade
```

![Example3](materials\example_03\update.png "обновление системы")
> Вывод команды apt upgrade

## Задание 5 Использование команды sudo

Для того чтоб добвить пользователя admin в группу sudo необходимо выполнить команду
```
sudo usermod -a -G admin
```
![Example3](materials\example_04\sudo_1.png "включаем пользователя в группу sudo")

##### возможно могут возникнуть проблемы в виде упрещенно оболочки для новго пользователя вместо оболчки bash может быть использована оболочка sh чтобы это исправить можно воспользоваться команой sudo chsh -s /bin/bash имя_пользователя
![Example3](materials\example_04\dopolnitelno.png "смена оболчки на bash")
>![Example3](materials\example_04\sudo_2.png "Проверяем что юзер тепеоб состоит в групе sudo")
>
>Проверка что пользователь теперь состоит в группу sudo


##### Теперь изменим имя хоста использую команду sudo hostname user-2

![Example3](materials\example_04\sudo_3.png "измиенеине имени хоста")

###  Истинное назначение команды sudo 
Команда sudo (сокращение от "superuser do") используется для выполнения команд с привилегиями суперпользователя (root). Истинное назначение команды sudo заключается в том, чтобы предоставить пользователям возможность выполнять команды с повышенными привилегиями, сохраняя при этом безопасность и контроль доступа. Это позволяет администраторам управлять правами пользователей и отслеживать действия, выполняемые с повышенными привилегиями, что делает систему более безопасной и управляемой.
1.  Повышение привилегий: sudo позволяет обычным пользователям выполнять команды, которые требуют административных прав, без необходимости входа в систему как суперпользователь. Это повышает безопасность, так как пользователи могут выполнять только те команды, которые им разрешены.
2.  Контроль доступа: С помощью файла конфигурации /etc/sudoers администраторы могут настраивать, какие пользователи или группы могут выполнять определенные команды с использованием sudo. Это позволяет ограничить доступ к критически важным системным функциям.
3.  Аудит и журналирование: Все команды, выполненные с использованием sudo, записываются в системный журнал. Это позволяет администраторам отслеживать, какие действия выполнялись с повышенными привилегиями, что полезно для аудита и безопасности.
4.  Безопасность: Использование sudo вместо входа в систему как root снижает риск случайного повреждения системы. Например, если вы работаете под обычной учетной записью и случайно выполните команду, которая может повредить систему, это будет менее опасно, чем если бы вы работали под root.
5.  Временные привилегии: sudo предоставляет временные привилегии. После выполнения команды с sudo пользователь возвращается к своим обычным правам. Это помогает предотвратить случайные изменения в системе.

## Задание 6.  Установка и настройка службы времени

Выведем текущие настройки службы времени с отображением часового пояса для этого используем следующие команды.
```
timedatectl show
```
и
```
timedatectl status
```
![Example3](materials\example_06\0.png "Вывод вышеуказанных команд")

После чего включим синхронизацию времени с помошью команды 
```
timedatectl set-ntp 1
```
![Example3](materials\example_06\3.png "Вывод вышеуказанных команд")

-------------------
В итоге получили

------------------
![Example3](materials\example_06\1.png "Вывод вышеуказанных команд")
> Вывод после проведенных манипуляций

## Задание 7. Установка и использование текстовых редакторов

В установленной операционной системе уже присутствуют редакторы VIM и NANO по этому дополнительно установим лишь один текстовый редактор MCEDIT 

Для этого выполнил следующую команду:
```
sudo apt-get install mc

```
Получим следующий вывод 

![Example7](materials\example_07\0.png "Вывод после установки MCEDIT ")

> Таким образом первая часть задания выполнена

Теперь используя каждый из трех выбранных редакторов, создадим файл test_X.txt, где X — название редактора, в котором создан файл. Напишем в них свой никнейм и закроем файлы с сохранением изменений.

#### Первым будем использовать VIM

![Example7](materials\example_07\1.png "Командная строка ")

> Создание файла test_vim 

Для редактирования текстового файла необходим нажать клавишу “ I ” после чего напишем текст 

![Example7](materials\example_07\2.png "Редактор VIM ")

после завершения ввода текста нажмем ESC после чего введем :qw – данная команда сохранить сделанные изменения и закроет файл

![Example7](materials\example_07\3.png "Редактор VIM ")

Проверим что файл записан cat test_vim

![Example7](materials\example_07\4.png "Редактор VIM ")

Теперь создадим файл с помощью nano и назовём test_nano
Используя команду `nano test_nano

![Example7](materials\example_07\5.png "Редактор NANO")

Для сохранения файла в редакторе нано необходимо зажать клавишу CTRL  и нажать O 
Редактор спросит хотим ли мы записать файло test_nano жмем ENTER

![Example7](materials\example_07\6.png "Редактор NANO")

После чего необходимо зажать клавишу CTRL  и нажать X для выхода.
Проверим сохранился ли наш файл командой cat test_nano 

![Example7](materials\example_07\7.png "Редактор NANO")

Теперь сделаем все таже самое но в редакторе MCEDIT

![Example7](materials\example_07\8.png "Редактор MCEDIT ")

Для сохранения файла в данном редакторе достаточно нажать клавишу F2 редактор также спросит нас хотим ли мы записать файл. После подтверждения необходимо для выхода нажать клавишу F10

![Example7](materials\example_07\9.png "Редактор MCEDIT ")

Проверим результат с помощью утилиты CAT

![Example7](materials\example_07\10.png "Bash")


Также убедимся что все три файла присутствуют

![Example7](materials\example_07\11.png " Bash ")

#### Теперь используя каждый из трех выбранных редакторов, откроем файл на редактирование, отредактируем файл, заменив никнейм на строку «21 School 21», после закроем файлы без сохранения изменений.

![Example7](materials\example_07\12.png " VIM ")

> VIM для выхода без изменений вводим q!

Проверим с помощью утили cat выведем содержание файла

![Example7](materials\example_07\13.png " содержание файла test_vim")

#### проделаем тоже самое с редактором nano

![Example7](materials\example_07\14.png " NANO ")

> NANO для выхода без изменений вводим CTRL X. Появится сообщение «Хотите ли вы сохранить файл» вводим n

Проверим с помощью утили cat выведем содержание файла

![Example7](materials\example_07\15.png " содержание файла test_nano")

#### проделаем тоже самое с редактором mcedit

![Example7](materials\example_07\16.png " mcedit ")


> MCEDIT для выхода без изменений вводим F10. Появится сообщение «Хотите ли вы сохранить 
>
>![Example7](materials\example_07\17.png " содержание файла test_ mcedit ")
>
>файл» выбираем «Нет»


Проверим с помощью утили cat выведем содержание файла

![Example7](materials\example_07\18.png " содержание файла test_ mcedit ")

#### Используя каждый из трех выбранных редакторов, отредактируем файл ещё раз (по аналогии с предыдущим пунктом), а затем освоим функции поиска по содержимому файла (слово) и замены слова на любое другое.

Для поиска в Vim необходимо поставить обратный слеш / после чего ввести искомое слово при нахождении слово будет выделено

![Example7](materials\example_07\19.png " поиск в vim")

Для авто замены наеденного слова необходимо вести
```
:s/искомое слово/на которое заменяем/
```
Чтобы заменить все вхождения шаблона поиска в текущей строке, добавьте флаг g
```
:s/искомое слово/на которое заменяем/g
```
Если вы хотите найти и заменить шаблон во всем файле, используйте процентный символ % в качестве диапазона. Этот символ указывает диапазон от первой до последней строки файла:
```
:% s/искомое слово/на которое заменяем/g 
```
![Example7](materials\example_07\20.png " поиск и автозамена в vim")
> результат замены поиска и автозамены слова

![Example7](materials\example_07\20.png " поиск в vim")

#### NANO поиск и авто замена

Откройте файл, который вы хотите выполнить поиск в Nano. Нажмите "Ctrl" + "W", чтобы начать поиск, а затем нажмите "Alt" + "C", чтобы заставить Nano искать слова с учетом регистра. Введите слово или фразу, которые вы хотите найти, убедившись, что прописные и строчные буквы соответствуют тому, что вы ищете. Нажмите Enter. Nano перейдет к любым совпадениям с буквами, которые вы ввели. Чтобы найти следующее совпадение, нажмите "Ctrl" + "W" и введите снова.

![Example7](materials\example_07\21.png " поиск в Nano ")

Для поиска замены текста в файле нажмите `Ctrl` + `\`. Введите слово, которое вы хотите изменить, и нажмите Enter. Nano покажет первое место, где это слово будет найдено. Введите новое слово и нажмите Enter, чтобы изменить только это. Или нажмите "A", чтобы изменить все. Когда закончите, нажмите "Ctrl" + "X" для сохранения и выхода.

![Example7](materials\example_07\22.png " поиск в Nano ")

![Example7](materials\example_07\23.png " поиск в Nano ")

**Результат**

![Example7](materials\example_07\24.png " поиск в Nano ")

### MCEDIT поиск и авто замена

#### Для поиска текста нажать F7

![Example7](materials\example_07\25.png " поиск в MCEDIT ")

![Example7](materials\example_07\26.png " поиск в MCEDIT ")

#### Для поиска и замены текста нажать F4

![Example7](materials\example_07\27.png " поиск в MCEDIT ")

![Example7](materials\example_07\28.png " поиск в MCEDIT ")

## Установка и базовая настройка сервиса SSHD

#### Установка службы SSHd

Sshd - это служба, принимающая запросы на соединения от клиентов. Обычно она запускается при загрузке системы из /etc/rc. Для каждого нового соединения создаётся (с помощью вызова fork) новый экземпляр службы. Ответвлённый экземпляр обрабатывает обмен ключами, шифрование, аутентификацию, выполнение команд и обмен данными.

Для установки службы нужно выполнить
```
sudo apt install openssh-server ssh
```

![Example8](materials\example_08\1.png " Установка SSH сервера")

Для того что бы добавить в автозагрузку SSH сервер необходимо ввести команду 
```
sudo systemctl enable sshd
```

![Example8](materials\example_08\2.png " Добавление SSH сервера в автозагрузку")

### Изменение порта службы sshd на порт 2022

Для этого необходимо открыть конфигурационный файл
```
mcedit /etc/ssh/sshd_config
```
Дале нобходимо найти строку Port 22 и изменить на 2022
После чего необходимо перезапустить сервер
```
sudo systemctl restart sshd
```
Как результат порт изменился на 2022

![Example8](materials\example_08\3.png " Добавление SSH сервера в автозагрузку")

#### Утилита ps одна из самых простых и в то же время часто используемых программ для просмотра списка процессов в Linux. 
-  -A, -e, (a) - выбрать все процессы;
-  -a - выбрать все процессы, кроме фоновых;
-  -d, (g) - выбрать все процессы, даже фоновые, кроме процессов сессий;
-  -N - выбрать все процессы кроме указанных;
-  -С - выбирать процессы по имени команды;
-  -G - выбрать процессы по ID группы;
-  -p, (p) - выбрать процессы PID;
-  --ppid - выбрать процессы по PID родительского процесса;
-  -s - выбрать процессы по ID сессии;
-  -t, (t) - выбрать процессы по tty;
-  -u, (U) - выбрать процессы пользователя.
####  Опции форматирования:
-  -с - отображать информацию планировщика;
-  -f - вывести максимум доступных данных, например, количество потоков;
-  -F - аналогично -f, только выводит ещё больше данных;
-  -l - длинный формат вывода;
-  -j, (j) - вывести процессы в стиле Jobs, минимум информации;
-  -M, (Z) - добавить информацию о безопасности;
-  -o, (o) - позволяет определить свой формат вывода;
-  --sort, (k) - выполнять сортировку по указанной колонке;
- -L, (H)- отображать потоки процессов в колонках LWP и NLWP;
-  -m, (m) - вывести потоки после процесса;
-  -V, (V) - вывести информацию о версии;
-  -H - отображать дерево процессов;

#### Запущенный процесс ssh сервера через команду ps

![Example8](materials\example_08\4.png " SSH сервер ")

![Example8](materials\example_08\5.png " SSH сервер")

### Вывод команды Вывод команды netstat -tan

![Example8](materials\example_08\6.png " SSH сервер")
Рис 1

Команда netstat (сокращение от "network statistics") используется для отображения сетевых соединений, таблиц маршрутизации, статистики интерфейсов и других сетевых данных. 
netstat -tan в данном случае используется 3 ключа
    -t: отображает только TCP-соединения.
    -a: показывает все соединения и прослушиваемые порты.
    -n: выводит адреса и номера портов в числовом формате, а не в виде имен хостов и сервисов.

Таким образом, команда netstat -tan выведет список всех активных TCP-соединений, включая те, которые находятся в состоянии прослушивания (LISTEN) и установленные соединения (ESTABLISHED), с указанием IP-адресов и портов в числовом формате.

**В выводе выше мы можем увидеть следующую информацию (рис 1)** 
-    **Proto — протокол (TCP).**
-    **Recv-Q и Send-Q — количество байтов в очереди на получение и отправку.**
-    **Local Address — локальный IP-адрес и порт.**
-    **Foreign Address — удаленный IP-адрес и порт.**
-    **State — состояние соединения (например, ESTABLISHED, LISTEN и т.д.).**

## Задание 9 Установка и использование утилит top, htop

Утилиты top и htop уже предустановлены в ubuntu 20.04 по этому манипуляций по их установке производить не нужно.
Обе утилиты нужны для отображения нагрузки на процессор память и т.д. данные утилиты помогают проанализировать нагрузку на сервер
Проанализировать, что именно нагружает сервер, можно с помощью специальных утилит. Их довольно много; в статье мы рассмотрим три из них:

В целом top и htop довольно похожи; работа с htop может быть немного удобнее за счет интерактивности.

Интерфейс утилиты топ выглядит так:

![Example9](materials\example_09\1.png "утилита top")

Далее буду выделять красной линией 

Uptime

![Example9](materials\example_09\2.png " Uptime")

количество авторизованных пользователей

![Example9](materials\example_09\3.png " количество авторизованных пользователей")

средняя загрузка системы

![Example9](materials\example_09\4.png " средняя загрузка системы")

общее количество процессов

![Example9](materials\example_09\5.png " общее количество процессов")

загрузку cpu

![Example9](materials\example_09\6.png " загрузку cpu ")


загрузку памяти

![Example9](materials\example_09\7.png " загрузку памяти ")


pid процесса занимающего больше всего памяти

![Example9](materials\example_09\8.png " средняя загрузка системы")
> pid процесса 680


pid процесса, занимающего больше всего процессорного времени.

![Example9](materials\example_09\9.png " средняя загрузка системы")
> pid процесса 1216
>

#### Интерфейс htop

![Example9](materials\example_09\10.png "htop ")

 #### Сортировки по PID, PERCENT_CPU, PERCENT_MEM, TIME;
![Example9](materials\example_09\11.png " Сортировка по PID ")
>  Сортировка по PID

![Example9](materials\example_09\12.png " Сортировка по PERCENT_CPU ")
>  Сортировка по PERCENT_CPU

![Example9](materials\example_09\13.png " Сортировка по PERCENT_MEM ")
>  Сортировка по PERCENT_MEM

![Example9](materials\example_09\14.png " Сортировка по TIME ")
>  Сортировка по TIME

#### отфильтровано для процесса sshd;

![Example9](materials\example_09\15.png " Фильтр  по sshd ")

#### с процессом syslog, найденным, используя поиск;

![Example9](materials\example_09\16.png " Фильтр  по syslog ")

#### с добавленным выводом hostname, clock и uptime.

![Example9](materials\example_09\17.png " добавление нужных параметров ")

- Добавим `hostname`, `clock` и `uptime` - добавление осуществляем через `F2`

## Задание 10. Использование утилиты fdisk

Для того что бы запустить утилиту fdisk необходимо ввести команду
```
sudo fdisk -l >report.txt
```
- >report.txt – не обязательный параметр так просто легче потом работать с выводом команды так как он перенаправляется в файл.

```
Название жесткого диска : VBOX HARDDISK
Размер : 25 Гб (26843545600 byte)
Количество секторов: 52428800
Размер swap: 2 Гб
```
![Example10](materials\example_10\0.png " ")

Чтобы узнать размер swap необходимо выполнить следующую команду
```
swapon –show
```

![Example10](materials\example_10\1.png " ")

## Задание 11. 

### Использование утилиты df

![Example11](materials\example_11\0.png " df ")

```
Размер раздела (/) = 11758760
Размер занятого пространства для (/) = 4899788
Размер свободного пространства для (/) = 6239864
Процент использования для (/) = 44%
Единица измерения = Килобайты
```
** df -Th**

![Example11](materials\example_11\1.png " df -Th ")

```
Размер раздела (/) = 12 Gb
Размер занятого пространства для (/) = 4.7 Gb
Размер свободного пространства для (/) = 6.0 Gb
Процент использования для (/) = 44%
Тип файловой системы: Ext4
```
Ext4 — это журналируемая файловая система, предлагаемая для использования по умолчанию инсталятором Ubuntu, начиная с версии 9.10. Количество индексных дескрипторов (i-node) задается только при создании ФС и в дальнейшем может быть только уменьшено1). При создании ФС приблизительно 1,8% объёма диска занимается служебными структурами ФС2), в дальнейшем размер этих данных увеличиваться будет только на размер каталогов файлов.

## Задание 12. Использование утилиты **du**

**du** - это команда для получения приблизительного объема дискового пространства, используемого указанными при вызове команды файлами или каталогами.

Запуск утилиты **du**

![Example12](materials\example_12\0.png " утилита du ")

Для вывода размера папок /home, /var, /var/log (в байтах, в человекочитаемом виде).
Необходимо использовать утилиту **du** со следующими ключами
```
du -hs /home /var/log /var  
```
Получаем вывод:

![Example12](materials\example_12\3.png " Вывод команды du -hs /home /var/log /var в байтах")

> Размер в байтах

![Example12](materials\example_12\1.png " Вывод команды du -hs /home /var/log /var в человеском виде")

> В "человеческом" виде

Для кастомизации вывода утилиты du можно использовать следующие ключи

- -a -- Выводить размер не только папок, но и файлов, которые там находятся
- -h -- Для того, чтобы размер выводился в более читабельном виде, а не в байтах.
- -c -- ключ вывода в конце общего размера всех папок
- -d -- максимальная глубина вложенности директорий не обходимо указать макс глубину вложения
- -s -- ключ вывода только общего размера (du -s /home будет выведен только общий размер папки home)

**Вывод размер всего содержимого в /var/log**

Для вывода всего содержимого необходимо в конце команды добавить символ *

```
du /var/log/*
```

Получаем вывод:

![Example12](materials\example_12\2.png " Вывод команды du du /var/log/*")

> Размер в байтах

![Example12](materials\example_12\4.png " Вывод команды du du /var/log/*")

> Более читаемы вывод размера

## Задание 13. Установка и использование утилиты ncdu

ncdu - это команда, имеющая то же назначение, что и du, но обладающая приятным и удобным интерфейсом.

Для запуска утилиты ncdu необходимо сначала ее установить командой

```
sudo apt install ncdu
```
![Example13](materials\example_13\0.png " Установка ncdu ")

- Использование программы элементарное. Для сканирования и обзора текущей директории, в которой вы находитесь, просто запустите программу ncdu: \
- Чтобы просканировать всю файловую систему, нужно указать путь. Для корня это слэш. Также пригодится опция -x — не выходить за пределы текущей файловой системы. Дело в том, что к корневой файловой системе могут быть смонтированы другие диски — и без этой опции они также будут посчитаны. 
- Для перехода в выбранную директорию используйте одну из следующих кнопок:
    - курсор вправо
    - ENTER
    - l
- Для возврата в родительскую директорию используйте одну из следующих кнопок:
    - курсор влево
    - <
    - h
- Для сортировки директорий и файлов используются следующие кнопки (нажмите ещё раз для обратного порядка):
    - n — по имени файла
    - s — по размеру файла
    - C — по количеству элементов

**размер папок /home, /var, /var/log.**

![Example13](materials\example_13\1.png " размер home ")

![Example13](materials\example_13\2.png " размер var ")

![Example13](materials\example_13\3.png " размер /var/log ")

- Использованные команды:
  - `ncdu /home`
  - `ncdu /var`
  - `ncdu /var/log`

## Задание 14. Работа с системными журналами.

Для открытия лог файла dmesg можно использовать любой из текстовых редакторов VIM, NANO, MCEDIT, утилиты cat, grep и т.д.
Откроем лог файл с помощью текстового редактора NANO
```
nano /var/log/dmesg
```
Получим следующий результат:

![Example14](materials\example_14\0.png " dmesg ")

Откроем syslog
```
cat /var/log/syslog | less
```

Получим следующий результат:

![Example14](materials\example_14\1.png " syslog ")

Откроем auth.log

```
cat /var/log/auth.log | less
```

Получим следующий результат:

![Example14](materials\example_14\2.png " auth.log ")

Для того чтобы узнать время последней успешной авторизации имя пользователя и метод входа можно воспользоваться командой lastlog которая выведет необходимую информацию.

![Example14](materials\example_14\3.png "lastlog")

либо использовать команду grep -i ahrigray /var/log/auth.log

![Example14](materials\example_14\4.png "grep -i ahrigray /var/log/auth.log")

- Таким образом время последнего удачного входа в систему = 09:57:44 
- Метод входа : uid = 0 (uid - User Identifier) 


- Перезапустим службу SSHd с помощью команды:
    ```
    sudo systemctl restart ssh
    ```

- В журналах auth.log и syslog найдем сообщение о перезапуске службы:

![Example14](materials\example_14\5.png "auth.log")

![Example14](materials\example_14\6.png "syslog")

## Задание 15. Использование планировщика задач CRON

Добавим в планировщик задач,  команду uptime которая буде запускаться каждые 2 минуты

```
crontab -e
```

- Добавим строчку `*/2 * * * * uptime`

![Example15](materials\example_15\0.png "crontab")

- После чего сохраним и закроем файл.

- Найдем в системных журналах строчки о выполнении `uptime`. Для этого воспользуемся командой:
    ```
    less /var/log/syslog | grep CRON
    ```
![Example15](materials\example_15\1.png "bash")

- Просмотрим список текущих задач для `CRON` - командой `crontab -l` :

![Example15](materials\example_15\2.png "crontab -l")

- Удалим все задания командой `crontab -r` и после этого проверим список задач командой `crontab -l` :

![Example15](materials\example_15\3.png "crontab -l")

Все задачи удалены.

# LinuxNetwork

## Задание №1 Инструмент ipcalc
 Для того чтобы использовать утилиту `ipcalc` необходимо её установить с этой целью выполняме команду `sudo apt install ipcalc`



### 1.1 Сети и маски.
- **Задание: определить и записать в отчет адрес сети 192.167.38.54/13**

Для этого необходимо выполнить комманду `ipcalc 192.167.38.54/13`

![pic](source/ex1/1.png)

- **Перевод маски 255.255.255.0 в префиксную и двоичную запись, /15 в обычную и двоичную**

Для этого необходимо выполнить `ipcalc 255.255.255.0` и `/15`
- **Обычная форма:** 255.255.255.0
- **Префиксная форма:** /24
- **Двоичная форма:** 11111111.11111111.11111111.00000000 
-------------

- **Префиксная форма:** /15
- **Обычная форма:** 255.254.0.0
- **Двоичная форма:** 11111111.11111110.00000000.00000000

![pic](source/ex1/2.png)

- **Минимальный и максимальный хост в сети 12.167.38.4 при масках: /8, 11111111.11111111.00000000.00000000, 255.255.254.0 и /4**

Для этого необходимо выполнить комманду `ipcalc 12.167.38.4/8` и `ipcalc 12.167.38.4/4`

![pic](source/ex1/3.png "создания скрипта конфигурирующего iptables")

>Для 12.167.38.4/8 
>>**Минимальный хост: 12.0.0.1** <br>
>>**Максимальный хост: 12.255.255.254** <br>

>Для 12.167.38.4/4
>>**Минимальный хост: 0.0.0.1** <br>
>>**Максимальный хост: 15.255.255.254** <br>

Вывод ipcalc при ip адресе 12.167.38.4 для масок 255.255.0.0 255.255.254.0

![pic](source/ex1/4.png "Для масок 255.255.0.0 255.255.254.0")

* **Для маски 255.255.0.0**
  - Максимальный хость: 12.167.0.1
  - Миниальный хост: 12.167.255.254
* **Для маски 255.255.0.0**
  - Максимальный хость: 12.167.38.1
  - Миниальный хост: 12.167.39.254 

 ### 1.2 LocalHost
 
 ***Задание: Определить и записать в отчет, можно ли обратиться к приложению, работающему на локальном хосте, со следующих ip адресов 194.34.23.100, 127.0.0.2, 127.1.0.1, 128.0.0.1***
 
 LocalHost находиться по адресу 127.0.0.1 это адрес, который используется для связи с самим устройством, на котором работает приложение.
 
 1) С ip адрессов <u>194.34.23.100</u> и <u>128.0.0.1</u> - Это внешние ip адреса, которые не относится к localhost. Обратиться к приложению на loalhost с этого ip адреса будет <u>**__невозможно__**</u>. Если конечно не нстроены правила маршрутизации или не используется прокси-сервер (на котором уже настроены правила маршрутизации).
 2) С ip адрессов 127.0.0.2, 127.1.0.1 установить связь приложению с localhost <u>**__получится__**</u>, так как данные адреса находятся в диапозоне <u>127.0.0.0/8</u>. Исходя из указанного перфикса дипозон адресов быдет таким:<br> **Начальный адрес:** <u>127.0.0.0</u> <br>**Конечный адрес:** <u>127.255.255.255</u>
 
 ### 1.3 Диапазоны и сегменты сетей
 
 IP-адреса делятся на публичные и частные. Частные IP-адреса используются в локальных сетях и не маршрутизируются в интернете.<br>
 Публичные IP-адреса маршрутизируются в интернете и видны за пределами частной сети<br>
 К частным сетям относятся следующие диапозоны ip адресов:
 

 
 * 10.0.0.0 - 10.255.255.255 (10.0.0.0/8)
 * 172.16.0.0 - 172.31.255.255 (172.16.0.0/12)
 * 192.168.0.0 - 192.168.255.255 (192.168.0.0/16)
 
**Таким образом к частным относятс IP-адреса:**
* 10.0.0.45
* 192.168.4.2
* 172.20.250.4
* 172.16.255.255
* 10.10.10.10

**К публичным IP-адресам:**
* 134.43.0.2
* 172.0.2.1
* 192.172.0.1
* 172.68.0.2
* 192.169.168.1

**Вопрос:**
<u>Какие из перечисленных IP-адресов шлюза возможны у сети 10.10.0.0/18: 10.0.0.1, 10.10.0.2, 10.10.10.10, 10.10.100.1, 10.10.1.255</u><br>
**Ответ:**<br>
Сеть 10.10.0.0/18 имеет маску: 255.255.192.0 (/18) данная сеть относится к классу A. Данная сеть может объеденить **16382** хостов.<br>
**Начальный адрес:** 10.10.0.1<br>
**Конечный адрес:** 10.10.63.254<br>
**Широковещательный адрес:** 10.10.63.255
![pic](source/ex1/5.png "1.3 Диапозоны и сегменты сетей")<br>
*Исходя из выше изложенного в сети 10.10.0.0/18 возможны следующие ip адреса:*<br>
**10.10.0.2**<br>
**10.10.1.255**<br>
**10.10.10.10**<br>
*Данные ip адреса не возможны в вышеуказанной сети*<br>
**10.0.0.1**<br>
**10.10.100.1**<br>

## Задание №2. Статическая маршрутизация между двумя машинами<br>


**== Задание ==<br>
Подними две виртуальные машины (далее -- ws1 и ws2).<br>
С помощью команды ip a посмотри существующие сетевые интерфейсы.**<br>
![pic](source/ex2/1.png "1 вывод команды ip a на двух ВМ")<br>


**Опиши сетевой интерфейс, соответствующий внутренней сети, на обеих машинах и задай следующие адреса и маски: ws1 — 192.168.100.10, маска /16, ws2 — 172.24.116.8, маска /12.**

В настоящий момент, как видно из скриншотов выше, сетевой интерфейс на обеих виртуальных машинах — enp0s3 с IP-адресом 10.0.2.4/24, что соответствует маске сети 255.255.255.0. Максимальное количество хостов, которое можно подключить к данной сети, составляет 254. Минимальный IP-адрес — 10.0.2.1, а максимальный — 10.0.2.254. Адрес 10.0.2.255 является широковещательным адресом.<br>
**Теперь изменим ip адреса в соответсвии с заданием, для этого необходимо изменить файл конфигурации Netplan.**<br>
Откроем файл конфигурации у меня он называется `00-installer-config.yaml` и на ходится он попути `/etc/netplan`
![pic](source/ex2/2.png "Файл конфигурации natplan")<br>
Внесем изменения соглано задания<br>
![pic](source/ex2/3.png "Файл конфигурации natplan")<br>
После внесения всех изменений такжед необходимо выполнить комманду ```netplan apply```<br>
![pic](source/ex2/4.png "проверка что изменения внесены")<br>

### 2.1 Добавление статического маршрута вручную

**Задача:**<br>
_Добавь статический маршрут от одной машины до другой и обратно при помощи команды вида ip r add.
Пропингуй соединение между машинами._<br><br>
Для добавления статического маршрута можно использовать комманду ```sudo ip route add 172.16.0.0/12 via 192.168.100.10``` - данная команда бы с работала если шлюз 192.... был доступен из сети 172.... так как это не так необходимо указать маршрут до сети 192... это можно сделать так ```sudo ip route add 172.16.0.0 dev enp0s3```. **enp0s3** - это название сетевого интерфейса через который будет осущетсвлятся дотуп к сети 172.... Также стоит отметить что данная комманда лишь временно внесет изменения в таблицу маршрутизации. Данные изменения будут действовать до перезагрузки системы либо до изменения удаления маршрута в ручную.<br> Чтобы создать постоянный маршрут который будет действовать и после презагрузки необходимо правть конфигурационный файл netplan.<br>
После выполнения команды ip route ... проверим соединение коммандой ping <br>
![pic](source/ex2/5.png "Добалвение маршрута и проверка связи между хостами посредствам комманды ping")<br>

### 2.2. Добавление статического маршрута с сохранением
**Перезапусти машины.<br>
Добавь статический маршрут от одной машины до другой с помощью файла /etc/netplan/00-installer-config.yaml.**<br>
Отредактируем файлы кофигурации netplan на обеих машинах<br>
![pic](source/ex2/6.png "Добавление статиеческого маршрута в конфигурационном файле netplan. Для этого добавили строку routes: ... (см. скриншот)")<br>
Добавим в конфигурационных файлах запись вида ```routes: - to 172.24.116.8/12 via: 192.168.100.10```, данный конфигурационный файл очень чуствителен к отступам.<br>
После всех манипуляций с файлами необходимо выполнить комманду ``netplan applay``. После проверим допступность хостов выполним команду `ping` на обоих хостах.<br>
![pic](source/ex2/7.png "Проверка связи между хостами")

## Задание №3 Утилита iperf3 <br>
**== Задание ==<br>
В данном задании используются виртуальные машины ws1 и ws2 из Части 2<br>
<u>3.1. Скорость соединения</u><br>
Переведи и запиши в отчёт: 8 Mbps в MB/s, 100 MB/s в Kbps, 1 Gbps в Mbps.**<br>
iperf3 — это утилита, предназначенная для измерения пропускной способности сети и тестирования производительности сетевых соединений. Она используется для оценки скорости передачи данных между двумя устройствами в сети и может помочь в диагностике проблем с сетью.<br>
Для использования утилиты iperf3 её необходимо установить ```sudo apt inastall iperf3```<br>
Как сказано выше утилитой iperf3 можно измерить скорость между двумя хостами для этого на одном из хостов запускается сервер коммандой ```iperf -s``` на другом хосте зпускается клиент который подключается по указнному ip адресу к порту по умолчнаю **5201** команда на втором хосте в моем случае будет выглядеть так ```iperf -c 192.168.100.10``` получаем результат: <br>
![pic](source/ex2/8.1.png "Результат работы утилиты iperf3")<br>
## Задание № 4. Сетевой экран
### 4.1 Утилита iptables
**В рамках задания необходимо создать файл /etc/firewall.sh, имитирующая фаервол, на обеих виртуальных машинах.**
```shell
#!/bin/sh

# Удаление всех правил в таблице «filter» (по умолчанию).
iptables -F
iptables -X
```
##### Нужно добавить в файл подряд следующие правила:
##### 1) На 1 виртулальной машине примени стратегию, когда в начале пишется запрещающее правило, а в конце пишется разрешающее правило (это касается пунктов 4 и 5). 
##### 2) На 2  виртулальной машине примени стратегию, когда в начале пишется разрешающее правило, а в конце пишется запрещающее правило (это касается пунктов 4 и 5).
##### 3) Открой на машинах доступ для порта 22 (ssh) и порта 80 (http).
##### 4) Запрети *echo reply* (машина не должна «пинговаться», т. е. должна быть блокировка на OUTPUT).
##### 5) Разреши *echo reply* (машина должна «пинговаться»).
- В отчёт помести скрины с содержанием файла */etc/firewall* для каждой машины.
##### Запусти файлы на обеих машинах командами `chmod +x /etc/firewall.sh` и `/etc/firewall.sh`.
- В отчёт помести скрины с запуском обоих файлов.
- В отчёте опиши разницу между стратегиями, применёнными в первом и втором файлах.<br>
![pic](source/ex4/1.png "Создания скрипта для конфигурации iptables")<rb>

Изменения прав доступа к файлу ```sudo chmode +x /etc/firewall.sh``` запуск скрипта ```sudo /etc/firewall.sh```. Вывод правил ```sudo iptables -L```<br>
![pic](source/ex4/2.png "Запуск написного скрипта + вывод политик (правил) феаеврола")<br>
Как мы видим из скриншота ниже после применения политик на ВМ 1 трафик не проходит но при этом с ВМ 2 трафик проходит.<br>
![pic](source/ex4/3.png "Вывод комманды ping")<br>
<u>**Разница между стратегиями:**</u><br>
**Запрещающее правило в начале и разрешающее в конце**<br>
В этой стратегии сначала устанавливаются правила, которые блокируют нежелательный трафик, а затем добавляются правила, разрешающие необходимый трафик. Это позволяет более строго контролировать доступ, так как по умолчанию все, что не разрешено, будет заблокировано. Таким образом, если в начале есть запрещающее правило, то только после него можно явно разрешить определённые типы трафика.

**Разрешающее правило в начале и запрещающее в конце** <br>
В этой стратегии сначала разрешается определённый трафик, а затем добавляются правила, которые блокируют нежелательный трафик. Это может быть менее безопасным подходом, так как по умолчанию разрешается больше трафика, и только затем устанавливаются ограничения. Если не все нежелательные типы трафика будут явно заблокированы, это может привести к уязвимостям.

### Утилита NMAP<br>
**Задание:**<br>
Командой ping найди машину, которая не «пингуется», после чего утилитой nmap покажи, что хост машины запущен.<br>
**Ниже приведен скриншот выполненого задания**.<br> *Скриншот совмещен с выводом команды ping и nmap.*<br>
![pic](source/ex4/4.png "Вывод комманды ping и nmap")<br>

## Задание 5. Статическая маршрутизация сети<br>
### Задание 5.1<br>
  *Создать 3 рабочие станции. В отчет поместить скриншоты с содержанием файла <u>etc/netplan/00-installer-config.yaml</u> для каждой машины*<br>
**Перезапусти сервис сети. Если ошибок нет, командой ip -4 a проверь, что адрес машины задан верно. Также пропингуй ws22 с ws21. Аналогично пропингуй r1 с ws11.**<br>
*В отчёт поместить скрины с вызовом и выводом использованных команд.*<br>
![pic](source/ex5/1.png "Скриншоты файла конфигурации netplan всех виртуальных машин а также выполнения ip -4 a проверка связи между хостами")<br>
### 5.2. Включение переадресации IP-адресов
**Задание:**<br>
*Для включения переадресации IP выполни команду на роутерах:
```sysctl -w net.ipv4.ip_forward=1``` <br>При таком подходе переадресация не будет работать после перезагрузки системы.<br>
В отчёт помести скрин с вызовом и выводом использованной команды.<br>
Открой файл ```/etc/sysctl.conf``` и добавь в него следующую строку:
`net.ipv4.ip_forward = 1`<br> При использовании этого подхода, IP-переадресация включена на постоянной основе.<br>
В отчёт помести скрин с содержанием изменённого файла `/etc/sysctl.conf.`*<br>
![pic](source/ex5/2.png "Выполнение команды sysctl -w net.ipv4.ip_forward=1")<br>
![pic](source/ex5/3.png "Редактирование файлов /etc/sysctl.conf расскоментирована строка net.ipv4.ip_forward = 1")<br>
### 5.3 Установка маршрута по умолчанию
**Задание.**<br> Необходимо задать  маршрут по умолчанию после чего сравнить вывод команда ```ip r``` из заддания.<br>
![pic](source/ex5/4.png "Ввод команды ip r из задания с которым необходимо сравнивать")<br>
**Задание: <u>Настрой маршрут по умолчанию (шлюз) для рабочих станций. Для этого добавь default перед IP-роутера в файле конфигураций.<br>В отчёт помести скрин с содержанием файла etc/netplan/00-installer-config.yaml;</u>**<br>
![pic](source/ex5/5.png "Скриншот файла etc/netplan/00-installer-config.yaml")<br>
**Задание: <u>Вызови ip r и покажи, что добавился маршрут в таблицу маршрутизации.<br>
В отчёт помести скрин с вызовом и выводом использованной команды.</u>**<br>
![pic](source/ex5/6.png)<br>
**Задание: <u>Пропингуй с ws11 роутер r2 и покажи на r2, что пинг доходит. Для этого используй команду:<br>
tcpdump -tn -i enp0s3<br>
В отчёт помести скрин с вызовом и выводом использованных команд.
</u>**<br>
![pic](source/ex5/7.png "Вызов комманды tcpdump -tn -i enp0s3")<br>
Утилита tcpdump используется для захвата и анализа сетевого трафика на сетевом интерфейсе.<br>
## 5.4. Добавление статических маршрутов
**Добавь в роутеры r1 и r2 статические маршруты в файле конфигураций. Пример для r1 маршрута в сетку 10.20.0.0/26:<br>
Добавь в конец описания сетевого интерфейса eth1:<br>
to: 10.20.0.0<br>
via: 10.100.0.12<br>
В отчёт помести скрины с содержанием изменённого файла etc/netplan/00-installer-config.yaml для каждого роутера.**<br>
Ниже приведен скриншот конфигурационного файла netplan в который были добавлены статические маршруты соглано задания. Были переименованы сетевые интерфейсы enp0s3 и enp0s8 в eth0 и eth1 соответсвенно.<br>
![picture](source/ex5/8.png "Скриншоты конфигурационных файлов netplan виртуальных машин R1 и R2")<br>
**Задание:**<br>
Вызови ip r и покажи таблицы с маршрутами на обоих роутерах. Пример таблицы на r1:<br>
![picture](source/ex5/9.png "Вызов ip r")<br>
**Задание:**<br>
![picture](source/ex5/11.png "Задание")<br>
![picture](source/ex5/10.png "Вывод вышеуказанной команды на WS11")<br>
При наличии двух маршрутов с разной маской для одного IP-адреса выбирается более специфический маршрут — с самой длинной маской, то есть в самую меньшую подсеть из доступных.
Тоесть для адреса 10.10.0.0/18 выбирается другой маршрут, поскольку он имеет более длинную маску, а следовательно более точный т.к. охватывает меньший диапазон адресов.<br>
Также во втором случае показан мрашрут default который используется для отправки пакетов, адресованных в сети, не указанных в таблице маршрутизации, это означает что для всех адресов, не подпадающих под другие маршруты, трафик будет отправляться на 10.10.0.1
### 5.5. Построение списка маршрутизаторов<br>
![picture](source/ex5/12.png "Задание")<br>
Ниже приведен скирн с выводмо вышеуказанных комманд.<br>
![picture](source/ex5/14.png "Рамкой выделена комманда traceroute от машины ws11 до ws21")<br>
**Принцип работы построения пути при помощи traceroute:**<br>
1. Traceroute начинает с отправки пакетов до целевого узла с установленным значением TTL, равным 1. Этот TTL определяет максимальное количество прыжков (то есть количество роутеров), через которые может пройти пакет. Когда пакет достигает первого роутера, TTL уменьшается на 1. Если TTL достигает нуля, роутер не отправляет пакет дальше, а посылает обратно ICMP-сообщение о превышении времени (TTL Exceeded).<br>
2. Traceroute принимает это ICMP-сообщение от первого роутера и запоминает его адрес. В это время также фиксируется время задержки, которое потребовалось пакету, чтобы дойти до роутера и вернуться обратно.<br>
3. Затем traceroute отправляет новые пакеты, увеличивая TTL на 1 (то есть, на втором этапе TTL будет равен 2). Этот процесс повторяется, позволяя traceroute "прыгать" от одного роутера к другому.<br>
4. Эта процедура продолжается до тех пор, пока не будет достигнут целевой узел (в ответ на который будет получено ICMP-сообщение "недостижимо") или пока не будет превышено максимальное значение TTL (обычно 30 или 64). В результате, traceroute создает список всех узлов (роутеров), через которые прошел пакет, включая время задержки для каждого узла.<br>
5. После завершения работы traceroute результаты отображаются в виде списка, где каждый узел представлен своей IP-адресом и (в некоторых случаях) доменным именем, а также временем, потребовавшимся для каждого "прыжка".<br>
### 5.6. Использование протокола ICMP при маршрутизации. <br>
![picture](source/ex5/15.png "Задание")<br>
![picture](source/ex5/16.png "Скриншот выполнения команд согласно задания на r1 и ws11")<br>
## Задание №6. Динамическая настройка IP с помощью DHCP.
**Задание:**<br>
![picture](source/ex6/1.png "Задание")<br>
Чтобы настроить dhcp серевер нужно его установить ```sudo apt install isc-dhcp-server```, но до этого необходимо дать доступ в нитернет машине r2 сетевой интерфейс с доступом в интернет у меня на машине r1 и все обновления остальных хостово делается через его подключение чтобы воспользоваться подлеючение на хосет r1 необходимо на самом хосте включить ```net.ipv4.ip_forward = 1``` что мы уже сделали ранее 
маршрут до r1 также уже есть остается только добавить правило в таблиц nat iptables коммандой ```sudo iptables -t nat -A POSTROUTING -o enp0s9 -j MASQUERADE```
![picture](source/ex6/2.png "Скриншоты конфигурационных файлов")<br>
**Дополнительные изменения в файле resolv.conf** <br>
![picture](source/ex6/5.png "resolv.conf")<br>
![picture](source/ex6/3.png "Задание")<br>
На скриншоте ниже указан результат выполнения следущих комманд ip a и ping<br>
![picture](source/ex6/7.png "презагрузка сервиса dhcp сервера")<br>
![picture](source/ex6/6.png "resolv.conf")<br>
![picture](source/ex6/9.png "Задание")<br>
![picture](source/ex6/8.png "Сркиншот изменений в файле 00-intaller-config.yaml")<br>
![picture](source/ex6/10.png "Задание")<br>
Отредактируем файл dhcpd.conf <br>
![picture](source/ex6/11.png "Сркиншот изменений в файле dhcpd.conf")<br>
Отредактируем файл resolv.conf на r1 <br>
![picture](source/ex6/12.png "Сркиншот изменений в файле resolv.conf")<br>
После проделанных манипуляций как на r2 перезагрузим сервис dhcp `sudo systemctl restart isc-dhcp-server` на r1 <br>
Пропингуем м машины ws11 машину ws22 результат приведен на скриншоте ниже.<br>
![picture](source/ex6/13.png "Сркиншот ping wd22")<br>
**Результат команды ip на ws21 до и после обновления** <br>
![picture](source/ex6/14.png "Сркиншот ping wd22")<br>
**Oпции DHCP:**<br>
1.<u> **range** - диапазон IP-адресов, присваиваемых клиентам.</u><br>
2.<u> **option routers** - шлюз по-умолчанию для клиентов.</u><br>
3.<u> **option domain-name-servers** - DNS-сервер для клиентов.</u><br>
4.<u> **host** - статическая привязка IP-адреса к MAC-адресу.</u><br>
5.<u> **hardware ethernet** - MAC-адрес клиента.</u><br>
6.<u> **fixed-address** - статический IP-адрес, присваемый клиенту по MAC-адресу.</u><br>

## Задание №7 NAT
![picture](source/ex7/1.png "Задание")<br>
Чтобы запустить веб-сервер **Apache** его также нужно скачать выпаолняем комманду `sudo apt install apache2`<br>
После установки редактиеруем ports.conf согласно задания.<br>
![picture](source/ex7/2.png "Настройки apache2")<br>
![picture](source/ex7/3.png "Задание")<br>
![picture](source/ex7/4.png "Запуск сервиса")<br>
![picture](source/ex7/5.png "Задание")<br>
Дабавим правило iptables на r2<br>
![picture](source/ex7/9.png "Скрипт фаервола")<br>
<u>После запуска скрипта с правилами машниа WS 22 перестала пинговаться с машины R1. См. скрин ниже</u><br>
![picture](source/ex7/6.png "Сркиншот ping ws22")<br>
На R2 в скрипте firewall.sh добавим еще одно правило `iptables -I FORWARD -p icmp -j ACCEPT`<br>
![picture](source/ex7/8.png "Сркиншот ping ws22")<br>
 После чего проверим дотупность ws 22<br>
![picture](source/ex7/7.png "Сркиншот ping ws22")<br>
![picture](source/ex7/10.png "Задание")<br>
Для этого также необходимо дабавить правила в iptbales для SNAT и DNAT в firewall на r2 смотри скриншот ниже.<br>
![picture](source/ex7/11.png "iptbales")<br>
**Соединение с ws 22 к r 1 (SNAT)**<br>
![picture](source/ex7/12.png "TELNET ПРОВЕРКА СОЕДИНЕНИЯ")<br>
**Соединение с r 1 к ws 22 (DNAT)**<br>
![picture](source/ex7/13.png "TELNET ПРОВЕРКА СОЕДИНЕНИЯ")<br>
## Задание №8 Дополнительное. Знакомство с SSH Tunnels
Перед заданием осуществляем запуск виртуальных машин сохраненных после выполнения задания 5.<br>
После чего запускаем фаервол на р2 с настройками из звдвния № 7.<br>
![picture](source/ex8/1.png "Запуск фаервола")<br>
На виртуальной машине 22 редактируем файл ports.conf<br>
![picture](source/ex8/2.png "Запуск фаервола")<br>
После чего на ws21 настраиваем **Local TCP Forwarding** (перенаправления трафика с локальной машины на сервер через SSH-туннель) применяется команда ```ssh -L```.<br>


**Результат команды ssh -L и telnet на ws21**<br>

![picture](source/ex8/3.png "Запуск фаервола")<br>
![picture](source/ex8/4.png "Запуск фаервола")<br>

**Результат команды ssh -R и telnet на ws11** <br>
![picture](source/ex8/5.png "Запуск фаервола")<br>

# Docker

## Part 1. Готовый докер<br>

**== Задание ==**

Возьми официальный докер-образ с nginx и выкачай его при помощи docker pull.<br>
Проверь наличие докер-образа через docker images.<br>
Запусти докер-образ через docker run -d [image_id|repository].<br>
Проверь, что образ запустился через docker ps.<br>
Посмотри информацию о контейнере через docker inspect [container_id|container_name].<br>
По выводу команды определи и помести в отчёт размер контейнера, список замапленных портов и ip контейнера.<br>
Останови докер контейнер через docker stop [container_id|container_name].<br>
Проверь, что контейнер остановился через docker ps.<br>
Запусти докер с портами 80 и 443 в контейнере, замапленными на такие же порты на локальной машине, через команду run.<br>
Проверь, что в браузере по адресу localhost:80 доступна стартовая страница nginx.<br>
Перезапусти докер контейнер через docker restart [container_id|container_name].<br>
Проверь любым способом, что контейнер запустился.<br>
•В отчёт помести скрины: ◦вызова и вывода всех использованных в этой части задания команд;
◦стартовой страницы nginx по адресу localhost:80 (адрес должен быть виден).<br>
**Замечание: Не загружай тяжелые файлы (>10 мб) в гит.**<br>
**Выполнение:**<br>

Для начала скачаем образ **nginx** с официального репазитория для этого октроем CMD и выполним комманду ```docker pull nginx```<br>

![simple_docker](Docker/source/ex1/1.png "выполнение команды docker pull nginx")<br>

**Проверим началие nginx в Images, как показано на скриншоте ниже данный образ в наличии)**<br>
![simple_docker](Docker/source/ex1/2.png )<br>
- Также проверим наличие образа через docker images и запустим образ чрезе docker run -d, используя docker ps убедимся что образ стартанул.<br>
![simple_docker](Docker/source/ex1/3.png)<br>
- Посмотрим информацию о контейнере через docker inspect и определим  размер контейнера, список замапленных портов и ip контейнера.<br>
![simple_docker](Docker/source/ex1/4.png)<br>
- Теперь остановим докер контейнер через docker stop  и проверим что  контейнер остановился через docker ps. <br>
![simple_docker](Docker/source/ex1/5.png)<br>
- Запустим докер с портами 80 и 443 в контейнере, замапленными на такие же порты на локальной машине, через команду run и проверим, что в браузере по адресу localhost:80 доступна стартовая страница nginx.<br>
![simple_docker](Docker/source/ex1/7.png)<br>
- Перезапустим докер контейнер чрез docker restart и проверим что образ перезаупстился через docker ps<br>
![simple_docker](Docker/source/ex1/8.png)<br>
> Как видно из скриншота выше серевер перезапустился так как при выводе запущенных выводов статус у образа стоит запущен 14 минут назад, а после запуска запущен 7 секунд назад.
<br>
<br>

## Part 2. Операции с контейнером
**Задание**
![simple_docker](Docker/source/ex2/1.png)<br>
Для упращение работы с запущенным оброзом запустим bash в контейнере ```docker exec -it 55cf90225df9 bash```<br>
- Результат выполнения вышеуказанной комманды:<br>
![simple_docker](Docker/source/ex2/2.png)<br>
- Прочитаем nginx.conf для этого в октрытом терминале bash контейнера выполним комманду ```cat /etc/nginx/nginx.conf```<br>
**Результат выполнения**<br>
![simple_docker](Docker/source/ex2/3.png)<br>
- Создадим на локальном пк файл nginx.conf<br>
![simple_docker](Docker/source/ex2/4.png)<br>
- Скопируем в образ созданный и отредактированный nginx.conf<br>
![simple_docker](Docker/source/ex2/6.png)<br>
![simple_docker](Docker/source/ex2/5.png)<br>
- После чего перезапустим службу nginx через комманду exec ```docker exec 55cf90225df9 nginx -s reload```<br>
![simple_docker](Docker/source/ex2/7.png)<br>
- Проверим, что по адресу localhost:80/status отображается страница со статусом сервера<br>
![simple_docker](Docker/source/ex2/8.png)<br>
- Экспортируем контейнер в файл `container.tar` для этой цели будем использовать команду `docker export -o container.tar [имя контейнера или id]` 
![simple_docker](Docker/source/ex2/9.png)<br>
- После выполения команды создаcтся архив файловой системы контейнера<br>
![simple_docker](Docker/source/ex2/14.png)<br>
- После чего останавливаем выполнение контейнера командой `docker stop [name]` убедимся что контейнер остановлен `docker ps`. После отобразим имеющиеся образы `docker images` откуда возьмем ID образа и подставим его в команду `docker rmi -f` для удаления образа<br>
![simple_docker](Docker/source/ex2/10.png)<br>
-Также удалим удалим контейнер командой `docker container rm 60c8a892f36f`
![simple_docker](Docker/source/ex2/15.png)<br>
- После проделаных манипуляций импортируем контейнер обратно через ```docker import -c "CMD [\"nginx\", \"-g\", \"daemon off;\"]" container.tar``` *ps: слеши в данном случае отдаем дань уважения cmd windows.*<br> Запустим контейнер командой ```docker run -d -p 80:80 a2724902c180``` и проверим работоспособность сервера *<u>nginx</u>* в браузере.<br>
![simple_docker](Docker/source/ex2/12.png)<br>

## Part 3. Мини веб-сервер
Напишем мини сервер на С с использованием библиотекеи FastCgi который будет возвращать страницу с напддисью  Hello World<br>
![simple_docker](Docker/source/ex3/3.png)<br>
После того как с комплировали файл запускаем контейнер и пробрасываем порты 81:81 после в запустившемся контейнере скачиваем библиотеку FastCgi -> libfcgi0ldbl, устанавливаем spawn-fcgi, копируем в контейнер отредактированный nginx.conf, и скомпилированный сервер `server` перезагружаем nginx и наконец запускапем spawn-fcgi `spawn-fcgi -f /home/server -p 8080` все вышеуказанные действи изображены на скриншотах ниже.<br>
![simple_docker](Docker/source/ex3/4.png)<br>
Так выглядит конфигаруционный файл nginx `nginx.conf`<br>
![simple_docker](Docker/source/ex3/1.png)<br>
**Проверяем работоспособность сервера**<br>
![simple_docker](Docker/source/ex3/2.png)<br>

## Part 4. Свой докер<br>
![simple_docker](Docker/source/ex4/1.png "Задание")<br>

Пишем докер файл<br>
![simple_docker](Docker/source/ex4/2.png)<br>

Запускаем dockerbuild командой `docker build . -t ahrigray:21`<br>
![simple_docker](Docker/source/ex4/3.png)<br>
Получаем новый образ <br>
![simple_docker](Docker/source/ex4/4.png)<br>

Запускаем собранный докер образ с маппингом 81 порта на 80 на локальной машине и проверям что на локал хосте доступна страничка ранее написанного сервера<br>
![simple_docker](Docker/source/ex4/5.png)<br>
Дописываем в ./nginx/nginx.conf проксирование странички /status, по которой надо отдавать статус сервера nginx<br>
![simple_docker](Docker/source/ex4/7.png)<br>
После чего перезапускаем докер-образ nginx проверяем доступна ли странчика статутса по адресу loacalhost/status<br>
![simple_docker](Docker/source/ex4/8.png)<br>
![simple_docker](Docker/source/ex4/6.png)<br>

## Part 5. Dockle<br>

Просканирум образ из предыдущего задания через dockle<br> 
![simple_docker](source/ex5/1.png)<br>
**Чтобы исправить ошибки изменим наш докер файл.**<br>
![simple_docker](Docker/source/ex5/2.png)<br>
Также перед сборкой образа а именно перед запуском докер файла необходимо установить переменную окруждения DOCKER_CONTENT_TRUST присвоив ей значение 1 так как я использую Windows перед запуском команды docker build выполним команду set DOCKER_CONTENT_TRUST=1. Делается это для того чтобы убрать предупреждение <br>
>INFO    - CIS-DI-0005: Enable Content trust for Docker
        * export DOCKER_CONTENT_TRUST=1 before docker pull/build
INFO    - CIS-DI-0008: Confirm safety of setuid/setgid files <br>

![simple_docker](Docker/source/ex5/3.png)<br>

## Part 6. Базовый Docker Compose

![simple_docker](Docker/source/ex6/1.png)<br>
Напишем docker-compose файл<br> 
![simple_docker](Docker/source/ex6/6.png)<br>
Подготовим файл nginx.conf файл для проксирования <br>
![simple_docker](Docker/source/ex6/7.png)<br>
Собрем и запустим проект с помощью команд docker-compose build и docker-compose up<br>
![simple_docker](Docker/source/ex6/2.png)<br>
![simple_docker](Docker/source/ex6/8.png)<br>
Проверим доступность нашего сервера а также странички с статистикой<br>
![simple_docker](Docker/source/ex6/3.png)<br>
![simple_docker](Docker/source/ex6/4.png)<br>


# CI/CD

## Basic CI/CD
![ex1](CI_CD/picture/ex1/1.png)

Согласно задания установим и запустим виртуальную машину с **Ubuntu Server 22.04 LTS**<br>
Для установки ``gitlab-runner`` воспользуемся утелитой ``curl``.<br> **curl** - это командная утилита, используемая для передачи данных с использованием различных сетевых протоколов, таких как HTTP, HTTPS, FTP и других. Она позволяет взаимодействовать с веб-серверами и API, загружать или отправлять данные, а также выполнять множество других сетевых операций.<br>
флаг -L указывает curl следовать за перенаправлениями.<br> 
После доабавления репазитория установливаем runner через ``apt install ...``<br>
![ex1](CI_CD/picture/ex1/6.png)<br>
Запустим и зарегистрируем gitlab-runner. Для регитсрации нам понадобиться URL и токен со страницы задания.<br>
![ex1](CI_CD/picture/ex1/5.png)<br>
После чего запустим гитлаб раннер ```sudo gitlab-runner register```<br>
![ex1](CI_CD/picture/ex1/4.png)<br>
> 1. Вводим адрес репазитория<br>
> 2. Вводим регистрационный токен<br>
> 3. Название ранера<br>
> 4. Присваиваем тэг<br>

## Part 2. Сборка

![ex2](CI_CD/picture/ex2/ex.png)<br>
Напишем файл gitlab-ci.yml с эапами запуска сборки через make файл из проекта cat/grep и положим его в "корень" DO6_CICD-1<br>
![ex2](CI_CD/picture/ex2/2.png)<br>
Чтобы хранить скомпилированные файлы 30 суток добавим параметр  artifacts<br>
В итоге после "пуша" получаем отчет<br>
![ex2](CI_CD/picture/ex2/1.png)<br>

## Part 3. Тест кодстайла
![ex3](CI_CD/picture/ex3/ex.png)<br>
До пишем в gitlab-ci.yml правило проверки clang-format-ом. А именно разкоменитрует стэйдж style. После чего определим и опишем задачу test_on_clangformat<br>
![ex3](CI_CD/picture/ex3/1.png)<br>
Запушим данные изменения в репазиторий и проверим работу тестов<br>
![ex3](CI_CD/picture/ex3/2.png)<br>
Как видим тест на кленг формат не прошел тест за фейлен. Раскроем ошибку и посмотрим почему тест за фейлился <br>
![ex3](CI_CD/picture/ex3/3.png)<br>
> На скриншоте совмещен вывод clang-format-а из wsl изображение сверху. Ниже приведен вывод кленга на гите.

Исправим ошибки стиля clang-format -i и запушим в репазиторей после чего проверим результат.<br>
Оба тетста завершены успешно. Если раскрыть лог на гитлабе по тесту на кленг формат увидим надпись Job succeeded<br>
![ex3](CI_CD/picture/ex3/4.png)<br>

## Part4 Интеграционные тесты
**Задание**
![ex4](CI_CD/picture/ex4/1.png)<br>
Напишем этам для CI который будет запускать интеграционные тесты проекта. Для этого внесем изменения в файл ``` gitlab-ci.yml``` <br>
![ex4](CI_CD/picture/ex4/7.png)<br>
>Изменения выделенны красным<br>

Отредактируес исходный файл си а именно выключим флаг -E у s21_cat после с компилируем и запустим тесты поулчим ошибку.<br>
![ex4](CI_CD/picture/ex4/8.png)<br>
За пушим в репозиторий.<br>
![ex4](CI_CD/picture/ex4/4.png)<br>
> Получая фэйл исполнения цели tests

![ex4](CI_CD/picture/ex4/5.png)<br>
Испраим сишный файл включим флаг -E и запушим в репазиторий.<br>
![ex4](CI_CD/picture/ex4/6.png)<br>
> Как видим тесты проходят

![ex4](CI_CD/picture/ex4/3.png)<br>
![ex4](CI_CD/picture/ex4/2.png)<br>

## Part 5. Этап деплоя
![ex5](CI_CD/picture/ex5/0.png)<br>
Создадим еще одну виртуальную машину я назвал ее CICD2<br>
![ex5](CI_CD/picture/ex5/9.png)<br>
После чего настроим локальную сеть между CICD и CICD2<br>
![ex5](CI_CD/picture/ex5/2.png)<br>
устновим и запустим ssh server<br>
![ex5](CI_CD/picture/ex5/3.png)<br>
Проверим пингуются ли между собой хосты<br>
![ex5](CI_CD/picture/ex5/1.png)<br>
После на машние с gilab-runner-ом сгенерируем ssh ключю `ssh-keygen` и скопируем ключ на сервер CICD2 коммандой `ssh-copy-id ahrigray@10.0.3.2` а также выполним комманду `ssh-keyscan -H 10.0.3.2 >> /home/gitlab-runner/.ssh/known_hosts`<br>
![ex5](CI_CD/picture/ex5/4.png)<br>
![ex5](CI_CD/picture/ex5/7.png)<br>
Отредактируем файл `gitlab-ci.yml` добавим stage deploy данный этап мы будем запускать в ручном режиме manual, а также напишем скрипт для bash deploy.sh, само копирование буде осуществлять через scp - (Secure Copy Protocol) используется для безопасной передачи файлов между локальной и удаленной машинами<br>
![ex5](CI_CD/picture/ex5/10.png)<br>
![ex5](CI_CD/picture/ex5/11.png)<br>
Запушим все в гит.<br>
![ex5](CI_CD/picture/ex5/6.png)<br>
Для продолжения необходимо запустить работу в ручную<br>
После чего плучаем результат. Который мы также проверим на хосте CICD2 как видим файлы находятся в папке deploy<br>
![ex5](CI_CD/picture/ex5/12.png)<br>
![ex5](CI_CD/picture/ex5/8.png)<br>
Стадия деплоя отработает. Стоит проверить и случай, когда пайплайн зафейлится. Для этого, уберем стадию build из файла `gitlab-ci.yml`. Получаем закономерный итог такак копировать нечего работа фейлится<br>
![ex5](CI_CD/picture/ex5/14.png)<br>
## Part 6. Дополнительно.Уведомления
![ex6](CI_CD/picture/ex6/3.png)<br>
Настроим уведомления об выполнении пайплайна через бота ahrigray_DO06CICD<br>
С начало на зарегистрировать нашего бота найдем в телеграмме `@BotFather`<br>
![ex6](CI_CD/picture/ex6/1.png)<br>
И зарегистрируем нашего бота<br>
![ex6](CI_CD/picture/ex6/2.png)<br>
После регистрации бота отправим ему сообщение после чего использую браузер переейдем по адресу ```<https://api.telegram.org/bot здесь полученный ранее токен /getUpdates>```<br>
Получим такой ответ:<br>
{<br>
  "ok": true,<br>
  "result": [<br>
    {<br>
      "update_id": 1111111111,<br>
      "message": {<br>
        "message_id": 6,<br>
        "from": {<br>
          "id": 111111111111,<br>
          "is_bot": false,<br>
          "first_name": "---------",<br>
          "username": "-----------",<br>
          "language_code": "ru"<br>
        },<br>
        **"chat": {<br>
          "id": 1111111111**,<br>
          "first_name": "----------",<br>
          "username": "----------",<br>
          "type": "private"<br>
        },
        "date": 1734624999,<br>
        "text": "/start"<br>,
        "entities": [<br>
          {
            "offset": 0,<br>
            "length": 6,<br>
            "type": "bot_command"<br>
нас интересует id в ветке chat<br>

Далле отредактируем `.gitlab-ci.yml` добавим после каждого стэйджа строки ` after_script:`
![ex6](CI_CD/picture/ex6/8.png)<br>
И напишем скрипт bot.sh<br>
![ex6](CI_CD/picture/ex6/6.png)<br>
В скрипте использованы переменные gitlab-а:<br>
1. CI_COMMIT_TAG: Имя тега, если пайплайн запущен для тега.
2. CI_PIPELINE_ID: Уникальный идентификатор текущего пайплайна.
3. CI_PIPELINE_URL: URL текущего пайплайна.
4. CI_PROJECT_ID: Уникальный идентификатор проекта.
5. CI_PROJECT_NAME: Имя проекта.
6. CI_PROJECT_URL: URL проекта.
7. CI_JOB_NAME: Имя текущей задачи.
8. CI_JOB_STAGE: Имя стадии, к которой принадлежит текущая задача.
9. CI_JOB_STATUS: Статус текущей задачи (например, success, failed, canceled).

В итоге получаем результат с начала я намеренно заапушил си файл который не продет проверку на клэнг формат после его исправил и запушли заново в телеграм получил следующие сообщения от бота<br>
![ex6](CI_CD/picture/ex6/7.png)<br>
Вот так выглядит пайпалм в на сайте<br>
![ex6](CI_CD/picture/ex6/5.png)<br>